\subsection{E2017120401: Base Performance Evaluation}
 
\subsubsection{Purpose}
To understand the baseline performance by using
the queries in ADBIS submission for XMark600.
 
\subsubsection{Settings} 

\begin{itemize}

\item \textbf{Hardware} HaoDesk (see \ref{HaoDesk})\\
\item \textbf{Software} BaseX 6.8.7, Java 1.8.0\_151.\\
\item \textbf{XML Dataset} XMark600.xml (see \ref{table:xmark}) sized 66.9 GB and
a BaseX databases `xmark600' is created by the server using command:\\
\verb|create db xmark600 xmark600.xml|
\item \textbf{Queries} xm1.org -- xm6.org (see ).

\end{itemize}


\subsubsection{Experiment Design}  

A BaseX instance Server first runs in server mode started by the following
command on HaoDesk.

\verb| java -Xmx4g -xms2g -cp BaseX897.jar org.basex.BaseXServer|

Note the databases in Server are all not in main memory mode.

Then, a java program APP runs on COM in charge of sending an input query to
Server via local network and saving results returned from Server to memory(short
for mem) or disk depending on settings. An input query Query that will be
processed in APP is first rewritten into the following XQuery expression:

\verb|for $node in db:open('xmark600')Query return $node|

The results are stored either in memory or on disk depending on APP's settings:
a) memory means the results are stored in memory and then discarded after the
experiments. b) disk means the results are stored in disk and will be preserved
after the experiments. One more thing, the maximum memory for APP was set to 12 GB.


\subsubsection{Experiment Results}

\textbf{Timing} The execution time is measured in APP. The time period between
starting sending a query and finishing receiving the results is measured as
execution time. Each query is evaluated 5 times. 

\textbf{Process Results}
We removed the results of the  first run and take the average of the rest as
the final execution time listed in Table~\ref{table:E2017120401_1}. 

 
71.25 
73.34 
113.05 
113.84 
83.59 
88.75 
78.42 
78.90 


\begin{table}[t]
	\caption{Experiment Results.}
	\label{table:E2017120401_1}
	\centering
	\begin{tabular}{c|c|c|r}
 		\hline \hline
 query  & storage & time(s)  &   result size  \\
 \hline \hline
 xm1.org &  disk   & 3257.13  & 60,048,845,586 \\
         & memory  &    N/A   &  \\
 \hline
 xm2.org &  disk   &    0.01  &              0 \\
         & memory  &    0.01  &  \\
  \hline
 xm3.org &  disk   &  71.25  &    922,270,281 \\
         & memory  &  73.34  &  \\
  \hline
 xm4.org &  disk   &  113.05  &  1,583,959,305 \\
         & memory  &  113.84  &  \\
  \hline
 xm5.org &  disk   &  83.59  &    989,346,990 \\
         & memory  &  88.75   &   \\
  \hline
 xm6.org &  disk   &  78.42   &  1,351,708,787 \\
         & memory  &  78.90   &   \\
 \hline \hline
	\end{tabular}
\end{table}


Note: The result of xm2.org is always empty (still under investigation).


\subsubsection{Observations}

\begin{itemize}
\item \textbf{Storage has small influence on execution time}
 
 We noticed one thing that the execution time is pretty similar for
 all the available queries. This is because the bottleneck is on the
 worker's side but not on the master's side. For example, for xm4.org,
 it takes 113s to receive about 1500 MB data, i.e. around 13.36 MB/s, 
 which is much slower than the maximum speed of both memory and disk. 
 Thus, the performance are much similar. We also notice that for some
 queries such as xm3.org and xm5.org, in-memory case is even a bit 
 slower than on-disk case, one possible explanation is that the time 
 was taken by calling System.gc(), since it researched the maxsimum 
 available memory.
 
\item \textbf{The execution time is steady}
 
 Compared with the ADBIS study, the execution time is much more
 steady. My explanation to this result is that due to the large scale
 of data, the fluctuation has a weaker influence on the execution
 time (milliseconds -> seconds). For you reference, the results and
 summary are saved in matsu-lab99:/home2/hao/fragmentation/20171202)
 By the way, since the results are still not fully correct, I will
 commit my code later after solve them.
\end{itemize}


 